
[handler:storage.content.new]
# pipeline = replication
pipeline =
# pipeline = webhook

[handler:storage.content.update]
# pipeline = replication
pipeline =

[handler:storage.content.append]
# pipeline = replication
pipeline =
# pipeline = webhook

[handler:storage.content.broken]
pipeline = content_rebuild

[handler:storage.content.deleted]
# pipeline = content_cleaner replication
pipeline = content_cleaner

[handler:storage.content.drained]
# pipeline = content_cleaner replication
pipeline = content_cleaner
# pipeline = webhook content_cleaner

[handler:storage.container.new]
# pipeline = account_update replication
pipeline = account_update

[handler:storage.container.update]
# pipeline = replication
pipeline =

[handler:storage.container.deleted]
# pipeline = account_update replication
pipeline = account_update

[handler:storage.container.state]
pipeline = account_update

[handler:storage.chunk.new]
pipeline = volume_index

[handler:storage.chunk.deleted]
pipeline = volume_index

[handler:storage.meta2.deleted]
pipeline = volume_index

[handler:account.services]
pipeline = account_update volume_index

# -----------------------------------------------------------------
# For object events: delete chunks
[filter:content_cleaner]
use = egg:oio#content_cleaner
# Allowed parameters:
# - backoff_factor (float, 0),
# - concurrency (int, 3)
# - max_retries (int, 0),
# - pool_connections (int, 32),
# - pool_maxsize (int, 32),
# Timeouts to the rawx service, in seconds
# (if timeout is not defined)
#connection_timeout=1.0
#read_timeout=5.0
#allow_retry=true

# -----------------------------------------------------------------
# For container events: update counters inside the account service
[filter:account_update]
use = egg:oio#account_update
# Timeouts to the account service, in seconds
#connection_timeout=2.0
#read_timeout=30.0

# -----------------------------------------------------------------
# Index meta2 or rawx content into rdir services
[filter:volume_index]
use = egg:oio#volume_index
# Time in seconds before an event should be reprocessed
retry_delay = 60


# -----------------------------------------------------------------
# Example of the notify filter: redirect some events to another tube,
# with a filter on the event's URL.
[filter:content_rebuild]
use = egg:oio#notify
tube = oio-rebuild
queue_url = ${QUEUE_URL}
# Exclude events whose URL matches these accounts and containers
exclude = AUTH_demo1,AUTH_demo2/trash
# Kafka endpoint
broker_endpoint = kafka://localhost:19092
topic = oio-rebuild

# -----------------------------------------------------------------
# Spread delete events accross rawx servers
[filter:delete]
use = egg:oio#delete
broker_endpoint = kafka://localhost:19092
topic_prefix = oio-delete-
# Time in seconds before an event should be reprocessed
retry_delay = 60
# Cache duration for rawx services
services_cache_duration = 3600

# -----------------------------------------------------------------
# Spread delete events accross rawx servers
[filter:blob_rebuilder]
use = egg:oio#blob_rebuilder
# Time in seconds before an event should be reprocessed
retry_delay = 60

# -----------------------------------------------------------------
# Retry events
[filter:delay]
use = egg:oio#delay
# Events time to live in seconds (one day)
events_time_to_live = 86400

# -----------------------------------------------------------------
# Example of the notify filter: redirect some events to another tube,
# with regular expressions on the storage policy.
[filter:notify_delete]
use = egg:oio#notify
queue_url = ${QUEUE_URL}

# Strip some fields from the event.
strip_fields = aliases,contents_headers

# Default tube
tube = oio-delete

# Regex and tube for EC storage policies.
policy_regex_EC = ^EC.*
tube_EC = oio-delete-ec

# Ensure fields are present in events (values are not checked)
required_fields = destinations

# -----------------------------------------------------------------
# Redirect event to the replication queue (deprecated).
[filter:replication]
use = egg:oio#replicate
tube = oio-repli
queue_url = ${QUEUE_URL}

# For each bucket, check if replication is enabled before forwarding
# replication events. This is disabled by default, meaning that all
# replication event will be forwarded (same behavior as before).
#check_replication_enabled=False

# Timeouts to the account service (telling if the replication
# is enabled or not for each bucket).
#connection_timeout=2.0
#read_timeout=30.0

# How long (seconds) and how many responses from the account service
# to keep in cache. Notice that the cache is per worker process.
#cache_duration=30.0
#cache_size=10000

# Ensure the master service is called for each request to the account service.
#force_master=False

# -----------------------------------------------------------------
# Does nothing. You'd better not defining any filter.
[filter:noop]
use = egg:oio#noop

# -----------------------------------------------------------------
# Call POST on an external URL with the event's body (unmaintained)
[filter:webook]
use = egg:oio#webhook
endpoint = http://localhost:8000/invoke

# -----------------------------------------------------------------
# Display the body of each event passing through (for debugging).
[filter:logger]
use = egg:oio#logger
#log_name=logger_filter
#log_format=X-OVH-TOKEN:XXXXXXXXX    topic:%(topic)s    event:%(event)s

# -----------------------------------------------------------------
# Bury each event passing through (for debugging).
[filter:bury]
use = egg:oio#bury
